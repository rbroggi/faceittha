// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: user.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetFirstName()) > 256 {
		err := UserValidationError{
			field:  "FirstName",
			reason: "value length must be at most 256 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetLastName()) > 256 {
		err := UserValidationError{
			field:  "LastName",
			reason: "value length must be at most 256 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNickname()) > 256 {
		err := UserValidationError{
			field:  "Nickname",
			reason: "value length must be at most 256 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = UserValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _User_Country_InLookup[m.GetCountry()]; !ok {
		err := UserValidationError{
			field:  "Country",
			reason: "value must be in list [AD AE AF AG AI AL AM AO AQ AR AS AT AU AW AX AZ BA BB BD BE BF BG BH BI BJ BL BM BN BO BQ BR BS BT BV BW BY BZ CA CC CD CF CG CH CI CK CL CM CN CO CR CU CV CW CX CY CZ DE DJ DK DM DO DZ EC EE EG EH ER ES ET FI FJ FK FM FO FR GA GB GD GE GF GG GH GI GL GM GN GP GQ GR GS GT GU GW GY HK HM HN HR HT HU ID IE IL IM IN IO IQ IR IS IT JE JM JO JP KE KG KH KI KM KN KP KR KW KY KZ LA LB LC LI LK LR LS LT LU LV LY MA MC MD ME MF MG MH MK ML MM MN MO MP MQ MR MS MT MU MV MW MX MY MZ NA NC NE NF NG NI NL NO NP NR NU NZ OM PA PE PF PG PH PK PL PM PN PR PS PT PW PY QA RE RO RS RU RW SA SB SC SD SE SG SH SI SJ SK SL SM SN SO SR SS ST SV SX SY SZ TC TD TF TG TH TJ TK TL TM TN TO TR TT TV TW TZ UA UG UM US UY UZ VA VC VE VG VI VN VU WF WS YE YT ZA ZM ZW]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

func (m *User) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *User) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

var _User_Country_InLookup = map[string]struct{}{
	"AD": {},
	"AE": {},
	"AF": {},
	"AG": {},
	"AI": {},
	"AL": {},
	"AM": {},
	"AO": {},
	"AQ": {},
	"AR": {},
	"AS": {},
	"AT": {},
	"AU": {},
	"AW": {},
	"AX": {},
	"AZ": {},
	"BA": {},
	"BB": {},
	"BD": {},
	"BE": {},
	"BF": {},
	"BG": {},
	"BH": {},
	"BI": {},
	"BJ": {},
	"BL": {},
	"BM": {},
	"BN": {},
	"BO": {},
	"BQ": {},
	"BR": {},
	"BS": {},
	"BT": {},
	"BV": {},
	"BW": {},
	"BY": {},
	"BZ": {},
	"CA": {},
	"CC": {},
	"CD": {},
	"CF": {},
	"CG": {},
	"CH": {},
	"CI": {},
	"CK": {},
	"CL": {},
	"CM": {},
	"CN": {},
	"CO": {},
	"CR": {},
	"CU": {},
	"CV": {},
	"CW": {},
	"CX": {},
	"CY": {},
	"CZ": {},
	"DE": {},
	"DJ": {},
	"DK": {},
	"DM": {},
	"DO": {},
	"DZ": {},
	"EC": {},
	"EE": {},
	"EG": {},
	"EH": {},
	"ER": {},
	"ES": {},
	"ET": {},
	"FI": {},
	"FJ": {},
	"FK": {},
	"FM": {},
	"FO": {},
	"FR": {},
	"GA": {},
	"GB": {},
	"GD": {},
	"GE": {},
	"GF": {},
	"GG": {},
	"GH": {},
	"GI": {},
	"GL": {},
	"GM": {},
	"GN": {},
	"GP": {},
	"GQ": {},
	"GR": {},
	"GS": {},
	"GT": {},
	"GU": {},
	"GW": {},
	"GY": {},
	"HK": {},
	"HM": {},
	"HN": {},
	"HR": {},
	"HT": {},
	"HU": {},
	"ID": {},
	"IE": {},
	"IL": {},
	"IM": {},
	"IN": {},
	"IO": {},
	"IQ": {},
	"IR": {},
	"IS": {},
	"IT": {},
	"JE": {},
	"JM": {},
	"JO": {},
	"JP": {},
	"KE": {},
	"KG": {},
	"KH": {},
	"KI": {},
	"KM": {},
	"KN": {},
	"KP": {},
	"KR": {},
	"KW": {},
	"KY": {},
	"KZ": {},
	"LA": {},
	"LB": {},
	"LC": {},
	"LI": {},
	"LK": {},
	"LR": {},
	"LS": {},
	"LT": {},
	"LU": {},
	"LV": {},
	"LY": {},
	"MA": {},
	"MC": {},
	"MD": {},
	"ME": {},
	"MF": {},
	"MG": {},
	"MH": {},
	"MK": {},
	"ML": {},
	"MM": {},
	"MN": {},
	"MO": {},
	"MP": {},
	"MQ": {},
	"MR": {},
	"MS": {},
	"MT": {},
	"MU": {},
	"MV": {},
	"MW": {},
	"MX": {},
	"MY": {},
	"MZ": {},
	"NA": {},
	"NC": {},
	"NE": {},
	"NF": {},
	"NG": {},
	"NI": {},
	"NL": {},
	"NO": {},
	"NP": {},
	"NR": {},
	"NU": {},
	"NZ": {},
	"OM": {},
	"PA": {},
	"PE": {},
	"PF": {},
	"PG": {},
	"PH": {},
	"PK": {},
	"PL": {},
	"PM": {},
	"PN": {},
	"PR": {},
	"PS": {},
	"PT": {},
	"PW": {},
	"PY": {},
	"QA": {},
	"RE": {},
	"RO": {},
	"RS": {},
	"RU": {},
	"RW": {},
	"SA": {},
	"SB": {},
	"SC": {},
	"SD": {},
	"SE": {},
	"SG": {},
	"SH": {},
	"SI": {},
	"SJ": {},
	"SK": {},
	"SL": {},
	"SM": {},
	"SN": {},
	"SO": {},
	"SR": {},
	"SS": {},
	"ST": {},
	"SV": {},
	"SX": {},
	"SY": {},
	"SZ": {},
	"TC": {},
	"TD": {},
	"TF": {},
	"TG": {},
	"TH": {},
	"TJ": {},
	"TK": {},
	"TL": {},
	"TM": {},
	"TN": {},
	"TO": {},
	"TR": {},
	"TT": {},
	"TV": {},
	"TW": {},
	"TZ": {},
	"UA": {},
	"UG": {},
	"UM": {},
	"US": {},
	"UY": {},
	"UZ": {},
	"VA": {},
	"VC": {},
	"VE": {},
	"VG": {},
	"VI": {},
	"VN": {},
	"VU": {},
	"WF": {},
	"WS": {},
	"YE": {},
	"YT": {},
	"ZA": {},
	"ZM": {},
	"ZW": {},
}

// Validate checks the field values on UserEvent with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserEventMultiError, or nil
// if none found.
func (m *UserEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *UserEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Before != nil {

		if all {
			switch v := interface{}(m.GetBefore()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserEventValidationError{
						field:  "Before",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserEventValidationError{
						field:  "Before",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBefore()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserEventValidationError{
					field:  "Before",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.After != nil {

		if all {
			switch v := interface{}(m.GetAfter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserEventValidationError{
						field:  "After",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserEventValidationError{
						field:  "After",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAfter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserEventValidationError{
					field:  "After",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserEventMultiError(errors)
	}

	return nil
}

// UserEventMultiError is an error wrapping multiple validation errors returned
// by UserEvent.ValidateAll() if the designated constraints aren't met.
type UserEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserEventMultiError) AllErrors() []error { return m }

// UserEventValidationError is the validation error returned by
// UserEvent.Validate if the designated constraints aren't met.
type UserEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserEventValidationError) ErrorName() string { return "UserEventValidationError" }

// Error satisfies the builtin error interface
func (e UserEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserEventValidationError{}

// Validate checks the field values on CreateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserRequestMultiError, or nil if none found.
func (m *CreateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetFirstName()) > 256 {
		err := CreateUserRequestValidationError{
			field:  "FirstName",
			reason: "value length must be at most 256 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetLastName()) > 256 {
		err := CreateUserRequestValidationError{
			field:  "LastName",
			reason: "value length must be at most 256 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNickname()) > 256 {
		err := CreateUserRequestValidationError{
			field:  "Nickname",
			reason: "value length must be at most 256 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPassword()); l < 8 || l > 20 {
		err := CreateUserRequestValidationError{
			field:  "Password",
			reason: "value length must be between 8 and 20 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = CreateUserRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateUserRequest_Country_InLookup[m.GetCountry()]; !ok {
		err := CreateUserRequestValidationError{
			field:  "Country",
			reason: "value must be in list [AD AE AF AG AI AL AM AO AQ AR AS AT AU AW AX AZ BA BB BD BE BF BG BH BI BJ BL BM BN BO BQ BR BS BT BV BW BY BZ CA CC CD CF CG CH CI CK CL CM CN CO CR CU CV CW CX CY CZ DE DJ DK DM DO DZ EC EE EG EH ER ES ET FI FJ FK FM FO FR GA GB GD GE GF GG GH GI GL GM GN GP GQ GR GS GT GU GW GY HK HM HN HR HT HU ID IE IL IM IN IO IQ IR IS IT JE JM JO JP KE KG KH KI KM KN KP KR KW KY KZ LA LB LC LI LK LR LS LT LU LV LY MA MC MD ME MF MG MH MK ML MM MN MO MP MQ MR MS MT MU MV MW MX MY MZ NA NC NE NF NG NI NL NO NP NR NU NZ OM PA PE PF PG PH PK PL PM PN PR PS PT PW PY QA RE RO RS RU RW SA SB SC SD SE SG SH SI SJ SK SL SM SN SO SR SS ST SV SX SY SZ TC TD TF TG TH TJ TK TL TM TN TO TR TT TV TW TZ UA UG UM US UY UZ VA VC VE VG VI VN VU WF WS YE YT ZA ZM ZW]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateUserRequestMultiError(errors)
	}

	return nil
}

func (m *CreateUserRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateUserRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateUserRequestMultiError is an error wrapping multiple validation errors
// returned by CreateUserRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserRequestMultiError) AllErrors() []error { return m }

// CreateUserRequestValidationError is the validation error returned by
// CreateUserRequest.Validate if the designated constraints aren't met.
type CreateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserRequestValidationError) ErrorName() string {
	return "CreateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserRequestValidationError{}

var _CreateUserRequest_Country_InLookup = map[string]struct{}{
	"AD": {},
	"AE": {},
	"AF": {},
	"AG": {},
	"AI": {},
	"AL": {},
	"AM": {},
	"AO": {},
	"AQ": {},
	"AR": {},
	"AS": {},
	"AT": {},
	"AU": {},
	"AW": {},
	"AX": {},
	"AZ": {},
	"BA": {},
	"BB": {},
	"BD": {},
	"BE": {},
	"BF": {},
	"BG": {},
	"BH": {},
	"BI": {},
	"BJ": {},
	"BL": {},
	"BM": {},
	"BN": {},
	"BO": {},
	"BQ": {},
	"BR": {},
	"BS": {},
	"BT": {},
	"BV": {},
	"BW": {},
	"BY": {},
	"BZ": {},
	"CA": {},
	"CC": {},
	"CD": {},
	"CF": {},
	"CG": {},
	"CH": {},
	"CI": {},
	"CK": {},
	"CL": {},
	"CM": {},
	"CN": {},
	"CO": {},
	"CR": {},
	"CU": {},
	"CV": {},
	"CW": {},
	"CX": {},
	"CY": {},
	"CZ": {},
	"DE": {},
	"DJ": {},
	"DK": {},
	"DM": {},
	"DO": {},
	"DZ": {},
	"EC": {},
	"EE": {},
	"EG": {},
	"EH": {},
	"ER": {},
	"ES": {},
	"ET": {},
	"FI": {},
	"FJ": {},
	"FK": {},
	"FM": {},
	"FO": {},
	"FR": {},
	"GA": {},
	"GB": {},
	"GD": {},
	"GE": {},
	"GF": {},
	"GG": {},
	"GH": {},
	"GI": {},
	"GL": {},
	"GM": {},
	"GN": {},
	"GP": {},
	"GQ": {},
	"GR": {},
	"GS": {},
	"GT": {},
	"GU": {},
	"GW": {},
	"GY": {},
	"HK": {},
	"HM": {},
	"HN": {},
	"HR": {},
	"HT": {},
	"HU": {},
	"ID": {},
	"IE": {},
	"IL": {},
	"IM": {},
	"IN": {},
	"IO": {},
	"IQ": {},
	"IR": {},
	"IS": {},
	"IT": {},
	"JE": {},
	"JM": {},
	"JO": {},
	"JP": {},
	"KE": {},
	"KG": {},
	"KH": {},
	"KI": {},
	"KM": {},
	"KN": {},
	"KP": {},
	"KR": {},
	"KW": {},
	"KY": {},
	"KZ": {},
	"LA": {},
	"LB": {},
	"LC": {},
	"LI": {},
	"LK": {},
	"LR": {},
	"LS": {},
	"LT": {},
	"LU": {},
	"LV": {},
	"LY": {},
	"MA": {},
	"MC": {},
	"MD": {},
	"ME": {},
	"MF": {},
	"MG": {},
	"MH": {},
	"MK": {},
	"ML": {},
	"MM": {},
	"MN": {},
	"MO": {},
	"MP": {},
	"MQ": {},
	"MR": {},
	"MS": {},
	"MT": {},
	"MU": {},
	"MV": {},
	"MW": {},
	"MX": {},
	"MY": {},
	"MZ": {},
	"NA": {},
	"NC": {},
	"NE": {},
	"NF": {},
	"NG": {},
	"NI": {},
	"NL": {},
	"NO": {},
	"NP": {},
	"NR": {},
	"NU": {},
	"NZ": {},
	"OM": {},
	"PA": {},
	"PE": {},
	"PF": {},
	"PG": {},
	"PH": {},
	"PK": {},
	"PL": {},
	"PM": {},
	"PN": {},
	"PR": {},
	"PS": {},
	"PT": {},
	"PW": {},
	"PY": {},
	"QA": {},
	"RE": {},
	"RO": {},
	"RS": {},
	"RU": {},
	"RW": {},
	"SA": {},
	"SB": {},
	"SC": {},
	"SD": {},
	"SE": {},
	"SG": {},
	"SH": {},
	"SI": {},
	"SJ": {},
	"SK": {},
	"SL": {},
	"SM": {},
	"SN": {},
	"SO": {},
	"SR": {},
	"SS": {},
	"ST": {},
	"SV": {},
	"SX": {},
	"SY": {},
	"SZ": {},
	"TC": {},
	"TD": {},
	"TF": {},
	"TG": {},
	"TH": {},
	"TJ": {},
	"TK": {},
	"TL": {},
	"TM": {},
	"TN": {},
	"TO": {},
	"TR": {},
	"TT": {},
	"TV": {},
	"TW": {},
	"TZ": {},
	"UA": {},
	"UG": {},
	"UM": {},
	"US": {},
	"UY": {},
	"UZ": {},
	"VA": {},
	"VC": {},
	"VE": {},
	"VG": {},
	"VI": {},
	"VN": {},
	"VU": {},
	"WF": {},
	"WS": {},
	"YE": {},
	"YT": {},
	"ZA": {},
	"ZM": {},
	"ZW": {},
}

// Validate checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserResponseMultiError, or nil if none found.
func (m *CreateUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateUserResponseMultiError(errors)
	}

	return nil
}

// CreateUserResponseMultiError is an error wrapping multiple validation errors
// returned by CreateUserResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserResponseMultiError) AllErrors() []error { return m }

// CreateUserResponseValidationError is the validation error returned by
// CreateUserResponse.Validate if the designated constraints aren't met.
type CreateUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserResponseValidationError) ErrorName() string {
	return "CreateUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserResponseValidationError{}

// Validate checks the field values on UpdateUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserRequestMultiError, or nil if none found.
func (m *UpdateUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetFirstName() != "" {

		if len(m.GetFirstName()) > 256 {
			err := UpdateUserRequestValidationError{
				field:  "FirstName",
				reason: "value length must be at most 256 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetLastName() != "" {

		if len(m.GetLastName()) > 256 {
			err := UpdateUserRequestValidationError{
				field:  "LastName",
				reason: "value length must be at most 256 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetNickname() != "" {

		if len(m.GetNickname()) > 256 {
			err := UpdateUserRequestValidationError{
				field:  "Nickname",
				reason: "value length must be at most 256 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetEmail() != "" {

		if err := m._validateEmail(m.GetEmail()); err != nil {
			err = UpdateUserRequestValidationError{
				field:  "Email",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetCountry() != "" {

		if _, ok := _UpdateUserRequest_Country_InLookup[m.GetCountry()]; !ok {
			err := UpdateUserRequestValidationError{
				field:  "Country",
				reason: "value must be in list [AD AE AF AG AI AL AM AO AQ AR AS AT AU AW AX AZ BA BB BD BE BF BG BH BI BJ BL BM BN BO BQ BR BS BT BV BW BY BZ CA CC CD CF CG CH CI CK CL CM CN CO CR CU CV CW CX CY CZ DE DJ DK DM DO DZ EC EE EG EH ER ES ET FI FJ FK FM FO FR GA GB GD GE GF GG GH GI GL GM GN GP GQ GR GS GT GU GW GY HK HM HN HR HT HU ID IE IL IM IN IO IQ IR IS IT JE JM JO JP KE KG KH KI KM KN KP KR KW KY KZ LA LB LC LI LK LR LS LT LU LV LY MA MC MD ME MF MG MH MK ML MM MN MO MP MQ MR MS MT MU MV MW MX MY MZ NA NC NE NF NG NI NL NO NP NR NU NZ OM PA PE PF PG PH PK PL PM PN PR PS PT PW PY QA RE RO RS RU RW SA SB SC SD SE SG SH SI SJ SK SL SM SN SO SR SS ST SV SX SY SZ TC TD TF TG TH TJ TK TL TM TN TO TR TT TV TW TZ UA UG UM US UY UZ VA VC VE VG VI VN VU WF WS YE YT ZA ZM ZW]",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return UpdateUserRequestMultiError(errors)
	}

	return nil
}

func (m *UpdateUserRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *UpdateUserRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UpdateUserRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateUserRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserRequestMultiError) AllErrors() []error { return m }

// UpdateUserRequestValidationError is the validation error returned by
// UpdateUserRequest.Validate if the designated constraints aren't met.
type UpdateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRequestValidationError) ErrorName() string {
	return "UpdateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRequestValidationError{}

var _UpdateUserRequest_Country_InLookup = map[string]struct{}{
	"AD": {},
	"AE": {},
	"AF": {},
	"AG": {},
	"AI": {},
	"AL": {},
	"AM": {},
	"AO": {},
	"AQ": {},
	"AR": {},
	"AS": {},
	"AT": {},
	"AU": {},
	"AW": {},
	"AX": {},
	"AZ": {},
	"BA": {},
	"BB": {},
	"BD": {},
	"BE": {},
	"BF": {},
	"BG": {},
	"BH": {},
	"BI": {},
	"BJ": {},
	"BL": {},
	"BM": {},
	"BN": {},
	"BO": {},
	"BQ": {},
	"BR": {},
	"BS": {},
	"BT": {},
	"BV": {},
	"BW": {},
	"BY": {},
	"BZ": {},
	"CA": {},
	"CC": {},
	"CD": {},
	"CF": {},
	"CG": {},
	"CH": {},
	"CI": {},
	"CK": {},
	"CL": {},
	"CM": {},
	"CN": {},
	"CO": {},
	"CR": {},
	"CU": {},
	"CV": {},
	"CW": {},
	"CX": {},
	"CY": {},
	"CZ": {},
	"DE": {},
	"DJ": {},
	"DK": {},
	"DM": {},
	"DO": {},
	"DZ": {},
	"EC": {},
	"EE": {},
	"EG": {},
	"EH": {},
	"ER": {},
	"ES": {},
	"ET": {},
	"FI": {},
	"FJ": {},
	"FK": {},
	"FM": {},
	"FO": {},
	"FR": {},
	"GA": {},
	"GB": {},
	"GD": {},
	"GE": {},
	"GF": {},
	"GG": {},
	"GH": {},
	"GI": {},
	"GL": {},
	"GM": {},
	"GN": {},
	"GP": {},
	"GQ": {},
	"GR": {},
	"GS": {},
	"GT": {},
	"GU": {},
	"GW": {},
	"GY": {},
	"HK": {},
	"HM": {},
	"HN": {},
	"HR": {},
	"HT": {},
	"HU": {},
	"ID": {},
	"IE": {},
	"IL": {},
	"IM": {},
	"IN": {},
	"IO": {},
	"IQ": {},
	"IR": {},
	"IS": {},
	"IT": {},
	"JE": {},
	"JM": {},
	"JO": {},
	"JP": {},
	"KE": {},
	"KG": {},
	"KH": {},
	"KI": {},
	"KM": {},
	"KN": {},
	"KP": {},
	"KR": {},
	"KW": {},
	"KY": {},
	"KZ": {},
	"LA": {},
	"LB": {},
	"LC": {},
	"LI": {},
	"LK": {},
	"LR": {},
	"LS": {},
	"LT": {},
	"LU": {},
	"LV": {},
	"LY": {},
	"MA": {},
	"MC": {},
	"MD": {},
	"ME": {},
	"MF": {},
	"MG": {},
	"MH": {},
	"MK": {},
	"ML": {},
	"MM": {},
	"MN": {},
	"MO": {},
	"MP": {},
	"MQ": {},
	"MR": {},
	"MS": {},
	"MT": {},
	"MU": {},
	"MV": {},
	"MW": {},
	"MX": {},
	"MY": {},
	"MZ": {},
	"NA": {},
	"NC": {},
	"NE": {},
	"NF": {},
	"NG": {},
	"NI": {},
	"NL": {},
	"NO": {},
	"NP": {},
	"NR": {},
	"NU": {},
	"NZ": {},
	"OM": {},
	"PA": {},
	"PE": {},
	"PF": {},
	"PG": {},
	"PH": {},
	"PK": {},
	"PL": {},
	"PM": {},
	"PN": {},
	"PR": {},
	"PS": {},
	"PT": {},
	"PW": {},
	"PY": {},
	"QA": {},
	"RE": {},
	"RO": {},
	"RS": {},
	"RU": {},
	"RW": {},
	"SA": {},
	"SB": {},
	"SC": {},
	"SD": {},
	"SE": {},
	"SG": {},
	"SH": {},
	"SI": {},
	"SJ": {},
	"SK": {},
	"SL": {},
	"SM": {},
	"SN": {},
	"SO": {},
	"SR": {},
	"SS": {},
	"ST": {},
	"SV": {},
	"SX": {},
	"SY": {},
	"SZ": {},
	"TC": {},
	"TD": {},
	"TF": {},
	"TG": {},
	"TH": {},
	"TJ": {},
	"TK": {},
	"TL": {},
	"TM": {},
	"TN": {},
	"TO": {},
	"TR": {},
	"TT": {},
	"TV": {},
	"TW": {},
	"TZ": {},
	"UA": {},
	"UG": {},
	"UM": {},
	"US": {},
	"UY": {},
	"UZ": {},
	"VA": {},
	"VC": {},
	"VE": {},
	"VG": {},
	"VI": {},
	"VN": {},
	"VU": {},
	"WF": {},
	"WS": {},
	"YE": {},
	"YT": {},
	"ZA": {},
	"ZM": {},
	"ZW": {},
}

// Validate checks the field values on UpdateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserResponseMultiError, or nil if none found.
func (m *UpdateUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserResponseValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserResponseValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserResponseMultiError(errors)
	}

	return nil
}

// UpdateUserResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateUserResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserResponseMultiError) AllErrors() []error { return m }

// UpdateUserResponseValidationError is the validation error returned by
// UpdateUserResponse.Validate if the designated constraints aren't met.
type UpdateUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserResponseValidationError) ErrorName() string {
	return "UpdateUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserResponseValidationError{}

// Validate checks the field values on RemoveUserRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RemoveUserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveUserRequestMultiError, or nil if none found.
func (m *RemoveUserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveUserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for HardDelete

	if len(errors) > 0 {
		return RemoveUserRequestMultiError(errors)
	}

	return nil
}

// RemoveUserRequestMultiError is an error wrapping multiple validation errors
// returned by RemoveUserRequest.ValidateAll() if the designated constraints
// aren't met.
type RemoveUserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveUserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveUserRequestMultiError) AllErrors() []error { return m }

// RemoveUserRequestValidationError is the validation error returned by
// RemoveUserRequest.Validate if the designated constraints aren't met.
type RemoveUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveUserRequestValidationError) ErrorName() string {
	return "RemoveUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveUserRequestValidationError{}

// Validate checks the field values on RemoveUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveUserResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveUserResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveUserResponseMultiError, or nil if none found.
func (m *RemoveUserResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveUserResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RemoveUserResponseMultiError(errors)
	}

	return nil
}

// RemoveUserResponseMultiError is an error wrapping multiple validation errors
// returned by RemoveUserResponse.ValidateAll() if the designated constraints
// aren't met.
type RemoveUserResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveUserResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveUserResponseMultiError) AllErrors() []error { return m }

// RemoveUserResponseValidationError is the validation error returned by
// RemoveUserResponse.Validate if the designated constraints aren't met.
type RemoveUserResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveUserResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveUserResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveUserResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveUserResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveUserResponseValidationError) ErrorName() string {
	return "RemoveUserResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveUserResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveUserResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveUserResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveUserResponseValidationError{}

// Validate checks the field values on ListUsersRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUsersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUsersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUsersRequestMultiError, or nil if none found.
func (m *ListUsersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUsersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageSize

	// no validation rules for Offset

	_ListUsersRequest_Countries_Unique := make(map[string]struct{}, len(m.GetCountries()))

	for idx, item := range m.GetCountries() {
		_, _ = idx, item

		if _, exists := _ListUsersRequest_Countries_Unique[item]; exists {
			err := ListUsersRequestValidationError{
				field:  fmt.Sprintf("Countries[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_ListUsersRequest_Countries_Unique[item] = struct{}{}
		}

		// no validation rules for Countries[idx]
	}

	if all {
		switch v := interface{}(m.GetCreatedAfter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListUsersRequestValidationError{
					field:  "CreatedAfter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListUsersRequestValidationError{
					field:  "CreatedAfter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAfter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUsersRequestValidationError{
				field:  "CreatedAfter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedBefore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListUsersRequestValidationError{
					field:  "CreatedBefore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListUsersRequestValidationError{
					field:  "CreatedBefore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedBefore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListUsersRequestValidationError{
				field:  "CreatedBefore",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListUsersRequestMultiError(errors)
	}

	return nil
}

// ListUsersRequestMultiError is an error wrapping multiple validation errors
// returned by ListUsersRequest.ValidateAll() if the designated constraints
// aren't met.
type ListUsersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUsersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUsersRequestMultiError) AllErrors() []error { return m }

// ListUsersRequestValidationError is the validation error returned by
// ListUsersRequest.Validate if the designated constraints aren't met.
type ListUsersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUsersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUsersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUsersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUsersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUsersRequestValidationError) ErrorName() string { return "ListUsersRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListUsersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUsersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUsersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUsersRequestValidationError{}

// Validate checks the field values on ListUsersResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListUsersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUsersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUsersResponseMultiError, or nil if none found.
func (m *ListUsersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUsersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUsersResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUsersResponseValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUsersResponseValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListUsersResponseMultiError(errors)
	}

	return nil
}

// ListUsersResponseMultiError is an error wrapping multiple validation errors
// returned by ListUsersResponse.ValidateAll() if the designated constraints
// aren't met.
type ListUsersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUsersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUsersResponseMultiError) AllErrors() []error { return m }

// ListUsersResponseValidationError is the validation error returned by
// ListUsersResponse.Validate if the designated constraints aren't met.
type ListUsersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUsersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUsersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUsersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUsersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUsersResponseValidationError) ErrorName() string {
	return "ListUsersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListUsersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUsersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUsersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUsersResponseValidationError{}
